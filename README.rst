==========
 pyvoronoi
==========

A wrapper for Boost's Voronoi diagram library

Install
=======

Dependencies
------------

Cython dependency is optional. Cpp sources generated with Cython are available in releases.

Note on using the setup.py:

setup.py operates in 2 modes that are based on the presence of the dev file in the root of the project.

* When dev is **present**, Cython will be used to compile the .pyx sources. This is the development mode (as you get it in the git repository).

* When dev is **absent**, C/C++ compiler will be used to compile the .cpp sources (that were prepared in in the development mode). This is the distribution mode (as you get it on PyPI).

This way the package can be used without or with an incompatible version of Cython.

The idea comes from Matt Shannon's bandmat library.

From PyPI
---------

Cython not required.

``pip install pyvoronoi``

From source
-----------

Cython required.

Clone the repository:

``git clone git@github.com:Voxel8/pyvoronoi.git``

Install:

``python setup.py install``

After every modification of .pyx files compile with Cython:

``python setup.py build_ext --inplace``

Using
=====

Create a new instance, passing the scaling factor into the constructor:
``` 
import pyvoronoi
pv = pyvoronoi.Pyvoronoi(10)
```

Since the voronoi library uses integer representation for points, the scaling factor chosen must be high enough
to avoid roundoff error when converting from point coordinates to integers.

Add points and segments:

.. code:: python

	pv.AddPoint([0, 0])
	pv.AddSegment([[1,5],[2,2]])

Call ``Construct()`` and get the edges and vertices:

.. code:: python

	pv.Construct()
	edges = pv.GetEdges()
	vertices = pv.GetVertices()
  cells = pv.GetCells()

Edges have the following properties:

* ``start, end`` contain the indices of the start and end vertices or ``-1`` if the edge is infinite at that end.
* ``is_primary`` is true if the edge is not coincident with any of the source inputs.
* ``is_linear`` is true if the edge is linear (not curved).
* ``site1, site2`` are the indices of the sites which generated this edge. Sites are indexed as points, then segments, so if there are 5 points and 3 segments, a site index of 7 means the last segment, a site index of 2 means the third point.
* ``cell`` is the identifier of the cell this segment is part of.
* ``twin`` is the identifier of the twin segment as defined in the boost voronoi API.

Cells have the following properties:
* ``cell_identifier`` is the index of the cell.
* ``site`` is the index of the site which generated this cell (same as site1, site2 on the edges).
* ``contains_point`` is true if the site was generated by a point.
* ``contains_segment`` is true if the site was generated by a segment.
* ``is_open`` is true if any of the cell's edges is infinite.
* ``vertices`` contains indices into the vertex array.
* ``edges`` contains indices into the edge array.

.. code:: python

    pv = pyvoronoi.Pyvoronoi(100)
    pv.AddSegment([[0.1,0.8],[0.3,0.6]])
    pv.AddSegment([[0.3,0.6],[0.4,0.6]])
    pv.AddSegment([[0.4,0.6],[0.4,0.5]])
    pv.AddSegment([[0.4,0.6],[0.4,0.7]])
    pv.AddSegment([[0.4,0.7],[0.5,0.8]])
    pv.AddSegment([[0.4,0.7],[0.5,0.6]])
    pv.AddSegment([[0.5,0.6],[0.7,0.7]])

    pv.Construct()
    edges = pv.GetEdges()
    vertices = pv.GetVertices()		
    cells = pv.GetCells()
    print("Cell Count: {0}".format(len(cells)))
    for c in cells:
        print("Cell contains point: {0}. Contains segment: {1}. Is open: {2}, Site Index: {3}".format(c.contains_point, c.contains_segment, c.is_open, c.site))
        print(",".join(map(str,c.vertices)))
        for sIndex in c.edges:
            print("Start Index: {0}, End Index = {1}".format(edges[sIndex].start, edges[sIndex].end))
			

Some output edges returned by the boost voronoi API are suposed to be curved. In the C++ API, it is up to you to code it. Luckily, you can do it in python using the following the function DiscretizeCurvedEdge.
The sample below shows you how to do that: 

.. code-block:: python
print "Insert into output edge table"
for cIndex in range(len(cells)):
    cell = cells[cIndex]
    if cell.is_open == False:
        for i in range(len(cell.edges)):    
            e = edges[cell.edges[i]]
            startVertex = vertices[e.start]
            endVertex = vertices[e.end]

            max_distance  = distance([startVertex.X, startVertex.Y], [endVertex.X, endVertex.Y]) / 10
            if startVertex != -1 and endVertex != -1:
                if(e.is_linear == True):
                    array = [[startVertex.X, startVertex.Y],[endVertex.X, endVertex.Y]]
                else:
                    points = pv.DiscretizeCurvedEdge(cell.edges[i], max_distance)
                    for p in points:
                        print "{0},{1}".format(p[0], p[1])

License
=======

-  Pyvoronoi is available under `MIT
   license <http://opensource.org/licenses/MIT>`__.
-  The core Voronoi library is available under `Boost Software
   License <http://www.boost.org/LICENSE_1_0.txt>`__. Freeware for both
   open source and commercial applications.
